C
C  THIS FILE CONTAINS THE BASIS PARAMETERS CONTROLLING THE INTEGRATION
C
 
      SUBROUTINE INITRK
 
      IMPLICIT REAL*8     ( A-F, P-Z )
      IMPLICIT COMPLEX*16 ( G, H )
      COMPLEX*16      XONE, XI, XZERO
      COMMON /PARAMS/ ZERO, XZERO, XONE, XI, TINY, PI, WO4PIS, IDFLT
      COMMON /INT   / XGSCAL(2), EPS, PGROW, PSHRNK, FCOR,
     .                SAFETY, ERRCON
      COMMON /INTSTP/ HTRY, HMIN
      REAL*8          HTRY, HMIN
C
C========< Entry Point >================================================
C
C--
C  Initialize parameters for RK integration.
C--
      HTRY   = 0.5D-2
      HMIN   = 0.5D-6
      ZERO   = 0.0D-30
      XZERO  = CMPLX(ZERO,ZERO)
      XONE   = CMPLX(1.0D0,ZERO)
      XI     = CMPLX(ZERO,1.0D0)
      TINY   = 1.0D-20
      PI     = ACOS(-1.D0)
      WO4PIS = (0.25D0/PI)**2
      PGROW  = -0.2D0
      PSHRNK = -0.25D0
      FCOR   = 1.0D0/15.0D0
      SAFETY = 0.9D0
      ERRCON = 6.0D-4
C--
C  ERRCON = (4/SAFETY)**(1/PGROW)
C--
      IDFLT = 1
C--
C  That's it.
C--
      RETURN
      END
C
C-----------------------------------------------------------------------
C--- Numerical integration package.
C
C   DRIVER FOR ADAPTIVE FOURTH-ORDER RUNGE-KUTTA INTEGRATION
C       FROM PRESS, FLANERY, TEUKOLSKY, AND VETTERLING
C  THIS ROUTINE INTEGRATES G  FROM TBEGIN TO TEND, ON A GRID
C     WHICH IS ADJUSTED TO THE ERROR CRITERIA IN COMMON/INT/
C  THE INITIAL VALUE OF G,GP IS INPUT IN GS,GPS, AND FINAL
C     VALUES ARE RETURNED IN GS(I)
C   THE VARIABLES IN THE COMMON/STOR/ STORE INTERMEDIATE VALUES:
C          KMAX IS THE MAXIMUM NUMBER OF STORED POINTS
C          DTP IS THE SUGGESTED DISTANCE IN T BETWEEN STORED POINTS
C          KOUNT IS THE ACTUAL NUMBER OF STORED POINTS
C          TP(J) AND GP(I,J) HOLD THE FUNCTION G(T)
C  THE DEFAULT VALUES OF  MAXSTP,  EPS,  KMAX,   DTP  ARE SET TO
C                          10000,   1.D-5,  200,   0.5D0
C   TO CHANGE THESE VALUES, SET IDFLT=0
C          AND SPECIFY ALL FOUR VALUES EXTERNALLY
C
 
      SUBROUTINE ODEINT(GS,GPS,TBEGIN,TEND)
 
      IMPLICIT REAL*8 (A-F,P-Z)
      IMPLICIT COMPLEX*16 (G,H)
      COMPLEX*16 XONE,XI,XZERO
      REAL*8 H,HTRY,HDID,HNEXT,HMIN
      COMMON/PARAMS/ZERO,XZERO,XONE,XI,TINY,PI,WO4PIS,IDFLT
      COMMON/INT/XGSCAL(2),EPS,PGROW,PSHRNK,FCOR,SAFETY,ERRCON
      COMMON/INTSTP/HTRY,HMIN
      COMMON/STOR/TP(1000),GP(2,1000),KOUNT,KMAX,DTP
      DIMENSION GS(2),G(2),GPR(2)
      N = 2
C  SET THE DIRECTION OF MOTION AND THE FIRST-TRY STEP SIZE
      IF (TEND.GT.TBEGIN) THEN
         DIR = 1.0D0
      ELSE
         DIR = -1.0D0
      END IF
      H = DIR * HTRY
      IF (IDFLT.NE.0) THEN
         MAXSTP = 10000
         EPS = 1.0D-5
         KMAX = 1000
         DTP = 0.00001D0
      END IF
      NOK = 0
      NBAD = 0
      KOUNT = 0
      T = TBEGIN
      DO 11 I = 1,N
         G(I) = GS(I)
   11 CONTINUE
C THIS STATEMENT INSURES THAT THE INITIAL CONDITIONS WILL BE STORED
      IF (KMAX.GT.0) TSAV = T-DTP* 2.0D0
      DO 16 NSTP =1,MAXSTP
         CALL RHS(T,G,GPR)
C   SET THE SCALE FOR THE ERROR CRITERION
         DO 12 I = 1,N
            XGSCAL(I) = CDABS(G(I)) + CDABS(H*GPR(I)) + TINY
   12    CONTINUE
C   CHECK WHETHER THE CURRENT INTERMEDIATE RESULT SHOULD BE STORED
         IF(KMAX.GT.0) THEN
            IF(DABS(T-TSAV).GT.DTP) THEN
               IF(KOUNT.LT.(KMAX-1)) THEN
                  KOUNT = KOUNT + 1
                  TP(KOUNT) = T
                  DO 13 I = 1,N
                     GP(I,KOUNT) = G(I)
   13             CONTINUE
                  TSAV = T
               END IF
            END IF
         END IF
         IF (DIR*(T+H-TEND).GT.ZERO) H = TEND-T
C  CALL THE NEXT RK STEP
         CALL RKQC(G,GPR,T,H,HDID,HNEXT)
         IF(HDID.EQ.H) THEN
            NOK = NOK+1
         ELSE
            NBAD = NBAD+1
         ENDIF
C  IF T = TEND HAS BEEN REACHED, EXIT GRACEFULLY
         IF(DIR*(T-TEND).GE.(-TINY)) THEN
            DO 14 I=1,N
               GS(I)=G(I)
   14       CONTINUE
            IF(KMAX.NE.0) THEN
               KOUNT = KOUNT+1
               TP(KOUNT) = T
               DO 15 I=1,N
                  GP(I,KOUNT) = G(I)
   15          CONTINUE
            END IF
C           PRINT  190, NOK,NBAD
  190        FORMAT('  DONE];  NO. OF  GOOD STEPS: ',I6,' BAD STEPS: ',
     *                   I6/)
            RETURN
         END IF
C   CHECK IF THE CURRENT STEP SIZE IS TOO SMALL
         IF(ABS(HNEXT).LT.HMIN) PRINT 200
  200         FORMAT('  STEPSIZE SMALLER THAN MINIMUM ')
         H = HNEXT
   16    CONTINUE
C   IF THE DO LOOP TERMINATES, EXIT UNGRACEFULLY
      PRINT 201
  201     FORMAT('   TOO MANY STEPS]  I QUIT] ')
      RETURN
      END
 
C
C   ADAPTER FOR FOURTH-ORDER RUNGE-KUTTA INTEGRATION
C       FROM PRESS, FLANERY, TEUKOLSKY, AND VETTERLING
C  THIS ROUTINE INTEGRATES G(I) FROM T FOR ONE STEP, WHICH IS
C    ADJUSTED FOR ACCURACY
C   HTRY SHOULD BE INPUT AS THE SUGGESTED STEP SIZE
C   HDID IS THE OUTPUT STEP SIZE ACTUALLY CHOSEN
C   HNEXT IS A PREDICTION FOR THE NEXT STEP SIZE
C
C   THE INTEGRATED FUNCTIONS ARE RETURNED IN G(I), AND THE
C             FINAL VALUE OF T IS RETURNED IN T
C
C  THE ACCURACY OF THE INTEGRATION IS CHECKED BY INTEGRATING OVER
C   INTERVALS H AND H/2 AND COMPARING THE RESULTS
C   TO A CRITERION XGSCAL(I) PASSED IN COMMON/INT/
C
 
      SUBROUTINE RKQC(G,GPR,T,HTRY,HDID,HNEXT)
 
      IMPLICIT REAL*8 (A-F,P-Z)
      IMPLICIT COMPLEX*16 (G,H)
      COMPLEX*16 XONE,XI,XZERO
      REAL*8 H,HH,HTRY,HDID,HNEXT
      DIMENSION G(2),GPR(2),GSAV(2),GPRSAV(2),GT(2)
      COMMON/PARAMS/ZERO,XZERO,XONE,XI,TINY,PI,WO4PIS,IDFLT
      COMMON/INT/XGSCAL(2),EPS,PGROW,PSHRNK,FCOR,SAFETY,ERRCON
      N = 2
C  FIRST, SAVE THE INITIAL CONDITIONS
      TSAV = T
      DO 11 I=1,N
         GSAV(I) = G(I)
         GPRSAV(I) = GPR(I)
   11 CONTINUE
      H = HTRY
    1 HH = H/2.0D0
C TAKE TWO RK4 STEPS OF SIZE HH
      CALL RK4(GSAV,GPRSAV,TSAV,HH,GT)
      T = TSAV + HH
      CALL RHS(T,GT,GPR)
      CALL RK4(GT,GPR,T,HH,G)
C TAKE ONE RK4 STEP OF SIZE H
      CALL RK4(GSAV,GPRSAV,TSAV,H,GT)
      T = TSAV + H
C COMPARE
      ERRMAX = TINY
      DO 12 I=1,N
         GT(I) = G(I) - GT(I)
         ERRMAX = DMAX1( ERRMAX, CDABS(GT(I)/XGSCAL(I)) )
   12 CONTINUE
      ERRMAX = ERRMAX/EPS
C IF THE TEST FAILS, SHRINK H
      IF (ERRMAX.GT.1.0D0)THEN
         H = SAFETY*H*(ERRMAX**PSHRNK)
         GO TO 1
      ELSE
         HDID = H
C IF THE TEST SUCCEEDS, USE A LARGER VALUE FOR THE NEXT H,
C  BUT NOT MORE THAN 4 TIMES LARGER
         IF (ERRMAX.GT.ERRCON) THEN
               HNEXT = SAFETY*H*(ERRMAX**PGROW)
         ELSE
               HNEXT = 4.0D0*H
         END IF
      END IF
C  IMPROVE THE ESTIMATE SLIGHTLY (TO 5TH ORDER RK)
C        BY USING THE H AND HH INFORMATION
      DO 13 I = 1,N
         G(I) = G(I) + GT(I)*FCOR
   13 CONTINUE
      RETURN
      END
C
C  FOURTH-ORDER RUNGE-KUTTA STEP,
C       FROM PRESS, FLANERY, TEUKOLSKY, AND VETTERLING
C   THIS ROUTINE STEPS THE FUNCTIONS G(I) FROM T OVER A STEP OF SIZE H,
C           PRODUCING THE VALUES GOUT(I)
C   THE VALUE OF THE RHS AT T SHOULD BE INPUT AS THE VARIABLES GPR(I)
C      VALUES OF THE RHS AT ADDITIONAL POINTS ARE COMPUTED INSIDE THE
C                            ROUTINE
C
 
      SUBROUTINE RK4(G,GPR,T,H,GOUT)
 
      IMPLICIT   REAL   *8  ( A-F, P-Z )
      IMPLICIT   COMPLEX*16 ( G-H )
      REAL   *8  T, H
      COMPLEX*16 G(2), GPR(2), GOUT(2)
      COMPLEX*16 GT(2), GPRA(2), GPRB(2)
      REAL   *8  HH, H6
C
      N = 2
      HH = H/2.0D0
      H6 = H/6.0D0
      TH = T + HH
C  FIRST STEP
      DO 11 I =1,N
         GT(I) =  G(I) + HH* GPR(I)
   11 CONTINUE
C SECOND STEP
      CALL RHS(TH,GT,GPRA)
      DO 12 I = 1,N
         GT(I) =  G(I) + HH*GPRA(I)
   12 CONTINUE
C THIRD STEP
      CALL RHS(TH,GT,GPRB)
      DO 13 I = 1,N
         GT(I) =  G(I) + H*GPRB(I)
         GPRB(I) = GPRA(I) + GPRB(I)
   13 CONTINUE
C FOURTH STEP
      CALL RHS((T+H),GT,GPRA)
C COMBINE THE RESULTS OF THE FOUR STEPS
      DO 14 I=1,N
         GOUT(I) = G(I) + H6*( GPR(I)+GPRA(I) + 2.0D0*GPRB(I) )
   14 CONTINUE
      RETURN
      END
